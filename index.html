<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>Akka workshop - taming akka</title>
	<meta name="description" content="Akka workshop">
	<meta name="author" content="VLTeam">

	<meta name="apple-mobile-web-app-capable" content="yes"/>
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

	<meta name="viewport"
	      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/black.css" id="theme">

	<!-- Code syntax highlighting -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<link rel="stylesheet" href="css/ts.css">

	<!-- Printing and PDF exports -->
	<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>

	<!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
</head>

<body>

<div class="reveal">

	<!-- Any section element inside of this container is displayed as a slide -->
	<div class="slides">

		<section data-markdown>
			<script type="text/template">
			<img class="ts-icon" src="imgs/vl.png" alt="Virtus Lab"/>

			<div class="lefty">
				<img class="ts-icon" src="imgs/gh.png" alt="Github: "> pkukielka
				<img class="ts-icon" src="imgs/twitter.png" alt="Twitter: "> @pkukielka
			</div>

			#### Piotr Kukiełka

			<div class="lefty">
				<img class="ts-icon" src="imgs/gh.png" alt="Github: "> liosedhel
				<img class="ts-icon" src="imgs/twitter.png" alt="Twitter: "> @liosedhel
			</div>

			#### Krzysztof Borowski

			<div class="lefty">
				<img class="ts-icon" src="imgs/gh.png" alt="Github: "> romanowski
				<img class="ts-icon" src="imgs/twitter.png" alt="Twitter: "> @RomanowskiKr
			</div>

			#### Krzysztof Romanowski


			<div class="lefty">
				<img class="ts-icon" src="imgs/gh.png" alt="Github: "> tgodzik
				<img class="ts-icon" src="imgs/twitter.png" alt="Twitter: "> @TomekGodzik
			</div>

			#### Tomasz Godzik

			<div class="lefty">
				<img class="ts-icon" src="imgs/gh.png" alt="Github: "> btomala
				<img class="ts-icon" src="imgs/twitter.png" alt="Twitter: "> @btomala
			</div>

			#### Bartłomiej Tomala

			</script>
		</section>

		<!-- ############################################################################################################### -->

		<section>
			<section data-markdown>
				<script type="text/template">
				## Akka Workshop

				### Remoting, supervision and clustering
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				## The Plan

				1. What is Akka?
				2. Connect and register.
				3. Process passwords.
				4. Parallelize your work.
				5. Handle your errors and supervise the minions.
				6. Terminate the straglers.
				7. Cluster!
				</script>
			</section>
        </section>
        <section>
            <section data-markdown>
                <script type="text/template">
				## What is Akka?

				### And what the hell is all this actor talk
                </script>
            </section>
            <section data-markdown>
                <script>
                    ## Actors
                </script>
            </section>
			<section data-markdown>
				<script type="text/template">
					###Have a state and some behaviour.

					![](actor_with_state.png)

				</script>
			</section>
            <section data-markdown>
				<script type="text/template">
					###Can send a finite number of messages to other actors.

					![](sending_messages.png)

				</script>
            </section>
            <section data-markdown>
				<script type="text/template">
					### Can create a finite number of new actors.

					![](finite_number_of_new_actors.png)

				</script>
            </section>
            <section data-markdown>
				<script type="text/template">
					### Designate the behavior to be used for the next message it receives.

					![](change_behaviour.png)

				</script>
            </section>
            <section data-markdown>
                <script>
				### Fault tolerance in Akka - key concepts.

				1. Let it crash.
				2. Multiple JVM.
				3. Self healing.
                </script>
            </section>
            <section data-markdown>
                <script>
                    ### Code samples
                </script>
            </section>
			<section data-markdown>
				<script>
				### Sample actor
				```scala
				class MyActor extends Actor {

					var someState:Int = 0

				    def receive : Receive = {
				        case message : String => println(message)
				    }

				}
				```
				</script>
			</section>
            <section data-markdown>
                <script>
				### Creating actor
				```scala
				val system = ActorSystem("SystemName")

				val actorRef = system.actorOf(new Worker("ActorName"))
				```
                </script>
            </section>


            <section data-markdown>
                <script>
                    ### But most of what you need is in the starting script.
                </script>
            </section>
        </section>

        <section>
	        <section data-markdown id="register">
		        <script type="text/template">
		        ## Connect and register
		        </script>
	        </section>

	        <section data-markdown>
		        <script type="text/template">
				### Basics
				```
				 > git clone https://github.com/VirtusLab/akka-workshop-client

				 > sbt run
				```
				### Leaderboard

				[headquarters:9000](http://headquarters:9000)
		        </script>
	        </section>

	        <section data-markdown>
		        <script type="text/template">
				### Find remote actor


				```scala
				val selection: ActorSelection = ???

				requesterActor ! selection
				```

				Actor address:
				```
				akka.tcp://application@headquarters:9552/user/PasswordsDistributor
				```


				Finding actors by path: https://doc.akka.io/docs/akka/2.5.11/general/addressing.html
		        </script>
	        </section>

			<section data-markdown>
				<script type="text/template">
					### Enable remote communication

					Dependency:
					```scala
					"com.typesafe.akka" %% "akka-remote" % "$akka.version$"
					```

					Remote akka configuration:
					```
					akka {
						actor {
							provider = remote
						}
						remote {
							enabled-transports = ["akka.remote.netty.tcp"]
							netty.tcp {
								hostname = "127.0.0.1"
								port = 2552
							}
						}
					}
					```


					More info: https://doc.akka.io/docs/akka/2.5/remoting.html
				</script>
			</section>

	        <section data-markdown>
		        <script type="text/template">
				### Send registration message

				```scala
			    case remoteActorSelection: ActorSelection =>
			      // TODO Register yourself by sending Register("your nick") to remote actor from selection
			      // HINT: Using actor ref instead of actor selection is recommended
			      println(s"Got remote actor selection: $remoteActorSelection")
				```

				We can send messages directly to actor selection but it's not recommended.

		        </script>
	        </section>
			<section data-markdown>
				<script type="text/template">
					### Register

					![](communication_step_1.png)
				</script>
			</section>

	        <section data-markdown>
		        <script type="text/template">
				### Get Actor Reference

				How can we obtain ActorRef instead?

				* using `sender()` method on any message received from `ActorSelection`
				* sending `Identify` message to `ActorSelection`
				* using `resolveOne` method of the `ActorSelection`

				https://doc.akka.io/docs/akka/2.5.11/actors.html#identifying-actors-via-actor-selection

		        </script>
	        </section>

	        <section data-markdown>
		        <script type="text/template">
				### Obtain unique ID

				```scala
				case Registered(token) =>
				    // Store and use this for other requests
				```

				Mutable state inside the actor is fine, but can we avoid it?
				Maybe we can just become actor who knows his ID?

				https://doc.akka.io/docs/akka/2.5.11/scala/actors.html#become-unbecome
		        </script>
	        </section>

			<section data-markdown>
				<script type="text/template">
				And see your name on leader board!

				![](leaderboard.png)

				[headquarters:9000?mode=remote](http:/headquarters:9000?mode=remote)

				Can you beat Jan or John? :)
				</script>
			</section>

        </section>
		<!-- ############################################################################################################### -->

		<section>

			<section data-markdown id="process">
				<script type="text/template">
				## Process passwords
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
					### Get password

					![](communication_step_2.png)
				</script>
			</section>

	        <section data-markdown>
		        <script type="text/template">
				### Request password

				```scala
				remote ! SendMeEncryptedPassword(token)
				```
		        </script>
	        </section>

	        <section data-markdown>
		        <script type="text/template">
				### Receive password

				```scala
				case EncryptedPassword(encrypted) =>
					// Decrypt and send it back using
					// ValidateDecodedPassword(token, original, decrypted)
				```

		        </script>
	        </section>

			<section data-markdown>
				<script type="text/template">
				### Decrypt password

				```scala
				val decrypter = new Decrypter
				val prepared = decrypter.prepare(password)
				val decoded = decrypter.decode(prepared)
				val decrypted = decrypter.decrypt(decoded)
				```

				Each operation is time consuming.

				Beware! Decrypter sometimes throws exceptions.
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				### Decrypter flaws:

				* There can be only a certain amount of decrypter instances in one JVM.
				* When one decrypter instance fails then **all** instances **silently** get corrupted and produce wrong results
				(Warning: you have to redo last step after any instance failure to have 100% correctness).

				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				### Verify result

				```scala
				remote ! ValidateDecodedPassword(token, encrypted, decrypted)
				```

				Possible responses:

				```scala
				case PasswordCorrect(decryptedPassword) => ???
				case PasswordIncorrect(decryptedPassword, correctPassword) => ???
				```
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				If you stay behind:

				```
				 > git checkout akka-remoting
				```
				</script>
			</section>
		</section>

		<!-- ############################################################################################################### -->

		<section>

			<section data-markdown id="parallel">
				<script type="text/template">
				## Parallelize your work

				Go up on the leaderboard!

				http:/headquarters:9000?mode=parallel
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				### Implementation goals

				* supervisor actor responsible for spawning multiple workers, dispatching work, and communicating with a central server
				* multiple worker actors responsible for password decryption
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				Watch out! There can only be a limited number of Decryptor instances.
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				Don't try to be perfect.

				We just want to decrypt passwords faster!
				</script>

			</section>

			<section data-markdown>
				<script type="text/template">
				### Design - RequesterActor

				Responsible for:

				* logging to server
				* spawning multiple workers
				* requesting encrypted passwords from server
				* dispatching work to workers
				* sending results (decrypted passwords) to server

				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				### Creating akka router

				```scala
				val router: ActorRef =
				context.actorOf(RoundRobinPool(5).props(Props[Worker]))
				```

				http://doc.akka.io/docs/akka/2.5.11/scala/routing.html
				</script>

			</section>

			<section data-markdown>
				<script type="text/template">
				### Design - Worker

				Responsible for:

				* getting encrypted passwords from router (RequesterActor)
				* decrypting passwords
				* sending them back to router (RequesterActor)

				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				### Creating Worker

				Worker is just normal akka actor.

				What will happen when exception will be thrown from Decryptor?
				How can we deal with that?

				* Ordinary exception catching for starter
				* Something more sophisticated later
				</script>

			</section>

			<section data-markdown>
				<script type="text/template">
				If you stay behind:
				```
				 > git checkout work-parallelization
				```
				</script>
			</section>
		</section>

		<!-- ############################################################################################################### -->

		<section>

			<section data-markdown id="errors">
				<script type="text/template">
				## Handle your errors and supervise the minions

				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				### Implementation goals

				* supervisor which can restart all workers in case of any error
				* retrying all broken computations
				</script>
			</section>
            <section data-markdown>
                <script type="text/template">
				### Creating supervision strategy

				We want to restart all workers if any of them will fail.

				```scala
				val restartingStrategy =
					AllForOneStrategy() { case _: Exception => Restart }
				val workers =
					context.actorOf(RoundRobinPool(
						workersNumber,
						supervisorStrategy = restartingStrategy
					).props(Worker.props))
				```

				https://doc.akka.io/docs/akka/2.5.11/general/supervision.html
                </script>

            </section>
			<section data-markdown>
				<script type="text/template">
				### Removing exception handling

				Supervisor will restart worker, but what about currently processing password?
				Can we try to process it again?

				We can get notified when we fail:

				```scala
				override def preRestart(reason: Throwable, message: Option[Any])
				```

				And we can send any message to ourselves:

				```scala
				self forward message
				```
				</script>
			</section>
			<section data-markdown>
				<script type="text/template">
				If you stay behind:
				```
				 > git checkout error-handling-supervision
				```
				</script>
			</section>

		</section>
		<!-- ############################################################################################################### -->

		<section>

			<section data-markdown>
				<script type="text/template">
				## Terminate the stragglers

				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				### Problem

				To decrypt password we need three steeps, all of them are time consuming.

				If any worker will break there is no point in continuing computations without restarting the state.

				Can we break others actors computations in the middle?

				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				### Solution

				[letitcrash.com/post/37854845601/little-pattern-message-based-loop](http://letitcrash.com/post/37854845601/little-pattern-message-based-loop)

				TL;DR:

				After each step in computation send result to yourself with all possible data to continue the task.
				</script>
			</section>



			<section data-markdown>
				<script type="text/template">
				Fibonacci numbers example:

				```scala
				case (max, result@(fibbCurrent :: fibbPrev :: tail)) =>
					if (fibbCurrent >= max) sender ! result
					else {
						val steps = (fibbCurrent + fibbPrev) :: result
						self forward (max, steps)
					}
				```

				In case of failure - just retry

				```
				override def preRestart(reason: Throwable, message: Option[Any]) {
					message foreach { self.forward }
				}
				```
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				If you stay behind:

				```
				 > git checkout terminating-long-running-tasks
				```
				</script>
			</section>

		</section>

		<!-- ############################################################################################################### -->

		<section>

			<section data-markdown>
				<script type="text/template">
				## Cluster!

				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				Since we are limited inside one JVM maybe we should connect more of them to beat best times so far?
				</script>
			</section>



			<section data-markdown>
				<script type="text/template">
				### Implementation goals

				* Cluster Singleton actor that will login to the central server and distribute work to all workers
				* Workers on each node connecting to that singleton actor
				* Changes to messages routing (varies depending on chosen strategy)
				</script>
			</section>
			<section>
				Architecture Example

				<img class="stretch" alt="clustering" src="clustering.png"/>

			</section>
            <section data-markdown>
                <script type="text/template">
				### Useful links

				* http://doc.akka.io/docs/akka/2.5.11/scala/cluster-usage.html
				* http://doc.akka.io/docs/akka/2.5.11/scala/cluster-singleton.html
                </script>
            </section>
			<section data-markdown>
				<script type="text/template">
					### Creating singleton
					```
					system.actorOf(ClusterSingletonManager.props(
						singletonProps = RequesterActor.props,
						terminationMessage = PoisonPill,
						settings = ClusterSingletonManagerSettings(system)),
						name = "consumer"
					)
					```
				</script>

			</section>
			<section data-markdown>
				<script type="text/template">
					### Creating singleton proxy
					```
					val singleton = system.actorOf(ClusterSingletonProxy.props(
						singletonManagerPath = "/user/consumer",
						settings = ClusterSingletonProxySettings(system)),
						name = "consumerProxy"
					)
					```
				</script>
			</section>
			<section data-markdown>
				<script type="text/templates">
				### Clustering configuration
				```
				akka {
					actor {
						provider = "akka.cluster.ClusterActorRefProvider"
					}
					remote {
						enabled-transports = ["akka.remote.netty.tcp"]
						untrusted-mode = off
						log-sent-messages = on
						log-received-messages = on
						netty.tcp {
							hostname = "127.0.0.1"
							port = 2553
						}
					}
					cluster {
						seed-nodes = [
							"akka.tcp://RequesterSystem@127.0.0.1:2553"
						]
					}
					loglevel = INFO
				}
				```
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				If you stay behind:

				```
				 > git checkout clustering
				```
				</script>
			</section>
		</section>

		<!-- ############################################################################################################### -->

		<section data-markdown>
			<script type="text/template">
			<img class="ts-icon" src="imgs/vl.png" alt="Virtus Lab"/>

			<div class="lefty">
				<img class="ts-icon" src="imgs/gh.png" alt="Github: "> pkukielka
				<img class="ts-icon" src="imgs/twitter.png" alt="Twitter: "> @pkukielka
			</div>

			#### Piotr Kukiełka

			<div class="lefty">
				<img class="ts-icon" src="imgs/gh.png" alt="Github: "> liosedhel
				<img class="ts-icon" src="imgs/twitter.png" alt="Twitter: "> @liosedhel
			</div>

			#### Krzysztof Borowski

			<div class="lefty">
				<img class="ts-icon" src="imgs/gh.png" alt="Github: "> romanowski
				<img class="ts-icon" src="imgs/twitter.png" alt="Twitter: "> @RomanowskiKr
			</div>

			#### Krzysztof Romanowski


			<div class="lefty">
				<img class="ts-icon" src="imgs/gh.png" alt="Github: "> tgodzik
				<img class="ts-icon" src="imgs/twitter.png" alt="Twitter: "> @TomekGodzik
			</div>

			#### Tomasz Godzik

			<div class="lefty">
				<img class="ts-icon" src="imgs/gh.png" alt="Github: "> btomala
				<img class="ts-icon" src="imgs/twitter.png" alt="Twitter: "> @btomala
			</div>

			#### Bartłomiej Tomala

			</script>
		</section>

		<!-- ############################################################################################################### -->
	</div>

</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});











</script>

</body>
</html>
adventurous
